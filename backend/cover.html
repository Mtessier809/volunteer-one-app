
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>controllers: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/VolunteerOne/volunteer-one-app/backend/controllers/eventController.go (100.0%)</option>
				
				<option value="file1">github.com/VolunteerOne/volunteer-one-app/backend/controllers/friendController.go (100.0%)</option>
				
				<option value="file2">github.com/VolunteerOne/volunteer-one-app/backend/controllers/loginController.go (100.0%)</option>
				
				<option value="file3">github.com/VolunteerOne/volunteer-one-app/backend/controllers/orgUsersController.go (100.0%)</option>
				
				<option value="file4">github.com/VolunteerOne/volunteer-one-app/backend/controllers/organizationController.go (100.0%)</option>
				
				<option value="file5">github.com/VolunteerOne/volunteer-one-app/backend/controllers/postsController.go (100.0%)</option>
				
				<option value="file6">github.com/VolunteerOne/volunteer-one-app/backend/controllers/usersController.go (33.3%)</option>
				
				<option value="file7">github.com/VolunteerOne/volunteer-one-app/backend/repository/eventRepository.go (100.0%)</option>
				
				<option value="file8">github.com/VolunteerOne/volunteer-one-app/backend/repository/friendRepository.go (100.0%)</option>
				
				<option value="file9">github.com/VolunteerOne/volunteer-one-app/backend/repository/loginRepository.go (100.0%)</option>
				
				<option value="file10">github.com/VolunteerOne/volunteer-one-app/backend/repository/orgUsersRepository.go (100.0%)</option>
				
				<option value="file11">github.com/VolunteerOne/volunteer-one-app/backend/repository/organizationRepository.go (100.0%)</option>
				
				<option value="file12">github.com/VolunteerOne/volunteer-one-app/backend/repository/postsRepository.go (100.0%)</option>
				
				<option value="file13">github.com/VolunteerOne/volunteer-one-app/backend/repository/usersRepository.go (53.8%)</option>
				
				<option value="file14">github.com/VolunteerOne/volunteer-one-app/backend/service/eventService.go (100.0%)</option>
				
				<option value="file15">github.com/VolunteerOne/volunteer-one-app/backend/service/friendService.go (100.0%)</option>
				
				<option value="file16">github.com/VolunteerOne/volunteer-one-app/backend/service/loginService.go (100.0%)</option>
				
				<option value="file17">github.com/VolunteerOne/volunteer-one-app/backend/service/orgUsersService.go (100.0%)</option>
				
				<option value="file18">github.com/VolunteerOne/volunteer-one-app/backend/service/organizationService.go (100.0%)</option>
				
				<option value="file19">github.com/VolunteerOne/volunteer-one-app/backend/service/postsService.go (100.0%)</option>
				
				<option value="file20">github.com/VolunteerOne/volunteer-one-app/backend/service/usersService.go (45.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package controllers

import (
        "net/http"
        "time"

        "github.com/VolunteerOne/volunteer-one-app/backend/models"
        "github.com/VolunteerOne/volunteer-one-app/backend/service"
        "github.com/gin-gonic/gin"
)

type EventController interface {
        Create(*gin.Context)
        All(*gin.Context)
        One(*gin.Context)
        Update(*gin.Context)
        Delete(*gin.Context)
}

type eventController struct {
        eventService service.EventService
}

// All implements EventController
func (controller eventController) All(c *gin.Context) <span class="cov8" title="1">{
        events, err := controller.eventService.GetEvents()

        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": err.Error(),
                })

                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, events)</span>
}

// Create implements EventController
func (controller eventController) Create(c *gin.Context) <span class="cov8" title="1">{
        var err error

        var body struct {
                OrganizationID uint
                Name           string
                Address        string
                Date           time.Time
                Description    string
                Interests      string
                Skills         string
                GoodFor        string
                CauseAreas     string
                Requirements   string
        }

        err = controller.eventService.Bind(c, &amp;body)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": err.Error(),
                })

                return
        }</span>

        <span class="cov8" title="1">event := models.Event{
                OrganizationID: body.OrganizationID,
                Name:           body.Name,
                Address:        body.Address,
                Date:           body.Date,
                Description:    body.Description,
                Interests:      body.Interests,
                Skills:         body.Skills,
                GoodFor:        body.GoodFor,
                CauseAreas:     body.CauseAreas,
                Requirements:   body.Requirements,
        }

        res, err := controller.eventService.CreateEvent(event)

        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": err.Error(),
                })

                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, res)</span>
}

// Delete implements EventController
func (controller eventController) Delete(c *gin.Context) <span class="cov8" title="1">{
        // Get the existing object
        id := c.Param("id")
        org, err := controller.eventService.GetEventById(id)

        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": err.Error(),
                })

                return
        }</span>

        // Delete the object
        <span class="cov8" title="1">err = controller.eventService.DeleteEvent(org)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": err.Error(),
                })

                return
        }</span>

        // Respond
        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "message": "Object deleted successfully",
        })</span>
}

// One implements EventController
func (controller eventController) One(c *gin.Context) <span class="cov8" title="1">{
        // Get the id
        id := c.Param("id")

        // Get object from the database
        event, err := controller.eventService.GetEventById(id)

        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": err.Error(),
                })

                return
        }</span>

        // Return the object
        <span class="cov8" title="1">c.JSON(http.StatusAccepted, event)</span>
}

// Update implements EventController
func (controller eventController) Update(c *gin.Context) <span class="cov8" title="1">{
        id := c.Param("id")

        event, err := controller.eventService.GetEventById(id)

        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": err.Error(),
                })

                return
        }</span>

        // Get updates from the body
        <span class="cov8" title="1">var body struct {
                OrganizationID uint
                Name           string
                Address        string
                Date           time.Time
                Description    string
                Interests      string
                Skills         string
                GoodFor        string
                CauseAreas     string
                Requirements   string
        }

        if err = controller.eventService.Bind(c, &amp;body); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": err.Error(),
                })

                return
        }</span>

        <span class="cov8" title="1">event.OrganizationID = body.OrganizationID
        event.Name = body.Name
        event.Address = body.Address
        event.Date = body.Date
        event.Description = body.Description
        event.Interests = body.Interests
        event.Skills = body.Skills
        event.GoodFor = body.GoodFor
        event.CauseAreas = body.CauseAreas
        event.Requirements = body.Requirements

        // Update the object
        result, err := controller.eventService.UpdateEvent(event)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": err.Error(),
                })

                return
        }</span>

        // Respond
        <span class="cov8" title="1">c.JSON(http.StatusOK, result)</span>
}

func NewEventController(s service.EventService) EventController <span class="cov8" title="1">{
        return eventController{
                eventService: s,
        }
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package controllers

import (
        "net/http"

        "github.com/VolunteerOne/volunteer-one-app/backend/models"
        "github.com/VolunteerOne/volunteer-one-app/backend/service"
        "github.com/gin-gonic/gin"
)

type FriendController interface {
        Create(c *gin.Context)
        Reject(c *gin.Context)
        Accept(c *gin.Context)
        One(c *gin.Context)
        All(c *gin.Context)
}

type friendController struct {
        friendService service.FriendService
}

func NewFriendController(s service.FriendService) FriendController <span class="cov8" title="1">{
        return friendController{
                friendService: s,
        }
}</span>

var friendModel = new(models.Friend)

func (controller friendController) Create(c *gin.Context) <span class="cov8" title="1">{
        var err error
        var body struct {
                FriendOneHandle string
                FriendTwoHandle string
        }
        err = controller.friendService.Bind(c, &amp;body)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Request body is invalid",
                })
                return
        }</span>

        <span class="cov8" title="1">object := models.Friend{
                FriendOneHandle: body.FriendOneHandle,
                FriendTwoHandle: body.FriendTwoHandle,
                RelationshipBit: "pending",
        }

        result, err := controller.friendService.CreateFriend(object)

        _ = result

        if err != nil </span><span class="cov8" title="1">{

                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Creation failed",
                })

                return
        }</span>

        // Respond
        <span class="cov8" title="1">c.JSON(http.StatusOK, object)</span>
}

func (controller friendController) Reject(c *gin.Context) <span class="cov8" title="1">{

        id := c.Param("id")

        result, err := controller.friendService.OneFriend(id)

        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Could not retrieve object",
                })

                return
        }</span>

        // Delete the object
        <span class="cov8" title="1">err1 := controller.friendService.RejectFriend(result)

        if err1 != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Could not delete object",
                })

                return
        }</span>

        // Respond
        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "message": "Object deleted successfully",
        })</span>

}

func (controller friendController) Accept(c *gin.Context) <span class="cov8" title="1">{
        id := c.Param("id")
        result, err1 := controller.friendService.OneFriend(id)

        if err1 != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Could not retrieve object",
                })

                return
        }</span>

        <span class="cov8" title="1">result.RelationshipBit = "friends"

        results1, err := controller.friendService.AcceptFriend(result)

        if err != nil </span><span class="cov8" title="1">{

                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Creation failed",
                })

                return
        }</span>

        // Respond
        <span class="cov8" title="1">c.JSON(http.StatusOK, results1)</span>
}

func (controller friendController) One(c *gin.Context) <span class="cov8" title="1">{

        id := c.Param("id")

        result, err1 := controller.friendService.OneFriend(id)

        if err1 != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Could not retrieve object",
                })

                return
        }</span>

        // Return the object
        <span class="cov8" title="1">c.JSON(http.StatusOK, result)</span>
}

func (controller friendController) All(c *gin.Context) <span class="cov8" title="1">{

        // Get object from the database
        friends, err := controller.friendService.GetFriends()

        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Could not retrieve objects",
                })

                return
        }</span>

        // Return the array of objects
        <span class="cov8" title="1">c.JSON(http.StatusOK, friends)</span>

}
</pre>
		
		<pre class="file" id="file2" style="display: none">package controllers

import (
        "log"
        "net/http"
        "os"
        "time"

        "github.com/VolunteerOne/volunteer-one-app/backend/models"
        "github.com/VolunteerOne/volunteer-one-app/backend/service"
        "github.com/gin-gonic/gin"
        "github.com/golang-jwt/jwt/v5"
)

// All Controller methods should be defined in the interface
type LoginController interface {
        Login(c *gin.Context)
        SendEmailForPassReset(c *gin.Context)
        PasswordReset(c *gin.Context)
        VerifyAccessToken(c *gin.Context)
        RefreshToken(c *gin.Context)
}

// The struct holds the reference to the corresponding service
type loginController struct {
        loginService service.LoginService
}

// Returns the new user controller -&gt; instantiated in router.go
func NewLoginController(s service.LoginService) LoginController <span class="cov8" title="1">{
        return loginController{
                loginService: s,
        }
}</span>

// Login:
// Gets the email and password as a parameter from the request
func (l loginController) Login(c *gin.Context) <span class="cov8" title="1">{
        log.Println("[LoginController] Logging in...")

        userInputU := c.Param("email")
        userInputP := c.Param("password")

        var user models.Users

        user, err := l.loginService.FindUserFromEmail(userInputU, user)

        // Email couldn't be found
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadGateway, gin.H{
                        "error":   "Email does not exist",
                        "success": false,
                })

                return
        }</span>

        // Check if the password matches
        // Compare the hashed password with the user input password
        <span class="cov8" title="1">erros := l.loginService.CompareHashedAndUserPass([]byte(user.Password), userInputP)
        if erros != nil </span><span class="cov8" title="1">{
                // Password does not match
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "Password does not match",
                        "success": false,
                })
                return
        }</span>

        // 15 minute expire for accessToken
        <span class="cov8" title="1">accessExpire := jwt.NewNumericDate(time.Now().Add(time.Minute * 15))
        // 30 day expire for refreshToken
        refreshExpire := jwt.NewNumericDate(time.Now().Add(time.Hour * 24 * 30))

        // generate the access token
        accessTokenClaims := jwt.MapClaims{
                "sub":  user.ID,
                "exp":  accessExpire,
                "type": "access",
        }
        accessToken, err := l.loginService.GenerateJWT(jwt.SigningMethodHS256, accessTokenClaims, os.Getenv("JWT_SECRET"))

        if err != nil </span><span class="cov8" title="1">{
                log.Println(err)
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "Failed to create access token",
                        "success": false,
                })
                return
        }</span>

        // generate the refreshToken
        <span class="cov8" title="1">refreshTokenClaims := jwt.MapClaims{
                "sub":  user.ID,
                "exp":  refreshExpire,
                "type": "refresh",
        }
        refreshToken, err := l.loginService.GenerateJWT(jwt.SigningMethodHS256, refreshTokenClaims, os.Getenv("JWT_SECRET"))

        if err != nil </span><span class="cov8" title="1">{
                log.Println(err)
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "Failed to create refresh token",
                        "success": false,
                })
                return
        }</span>

        // Store the refresh token in the Delegations table
        <span class="cov8" title="1">var delegations models.Delegations

        // Save the code
        err = l.loginService.SaveRefreshToken(user.ID, refreshToken, delegations)

        if err != nil </span><span class="cov8" title="1">{
                log.Println(err)
                c.JSON(http.StatusBadRequest, gin.H{
                        "message": "Failed to save refresh token to DB",
                        "success": false,
                })
                return

        }</span>

        // Send the access/refresh token
        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "message":       "Successfully logged in",
                "access_token":  accessToken,
                "refresh_token": refreshToken,
                "success":       true,
        })</span>

}

func (l loginController) SendEmailForPassReset(c *gin.Context) <span class="cov8" title="1">{
        log.Println("Entering SendEmailForPassReset function")

        //First find if the email exist
        //if it does then send reset code
        //if not, send back request that it does not exist
        userInputU := c.Param("email")
        var user models.Users
        user, err := l.loginService.FindUserFromEmail(userInputU, user)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadGateway, gin.H{
                        "message": "Email does not exist",
                        "success": false,
                })
                return
        }</span>

        //Generate reset code
        <span class="cov8" title="1">resetCode := l.loginService.GenerateUUID()

        err = l.loginService.SaveResetCodeToUser(resetCode, user)

        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "message": "Could not save reset code to user",
                        "success": false,
                })
                return
        }</span>
        //Send reset code to user's email address
        <span class="cov8" title="1">err = l.loginService.SendResetCodeToEmail(user.Email, resetCode.String())

        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "message": "Failed to send email",
                        "success": false,
                        //"error messsage": err,
                })
                return
        }</span>
        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "message": "Email has been sent!",
                "success": true,
                //"resetCode": resetCode,
        })
        return</span>

}

func (l loginController) PasswordReset(c *gin.Context) <span class="cov8" title="1">{
        email := c.Param("email")
        resetCode := c.Param("resetcode")
        resetCodeParsed, err := l.loginService.ParseUUID(resetCode)

        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "message": "Could not parse UUID",
                        "success": false,
                })
                return
        }</span>

        <span class="cov8" title="1">newPassword := c.Param("newpassword")

        var user models.Users

        //Retrieve user's record by their email
        user, ero := l.loginService.FindUserFromEmail(email, user)
        if ero != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadGateway, gin.H{
                        "message": "Email does not exist",
                        "success": false,
                })
                return
        }</span>
        //See if reset code is matched with the one they provided
        <span class="cov8" title="1">if user.ResetCode != resetCodeParsed </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "message": "Failed to provde correct reset code",
                        "success": false,
                })
                return
        }</span>
        <span class="cov8" title="1">hash, _ := l.loginService.HashPassword([]byte(newPassword))
        if changePasswordErr := l.loginService.ChangePassword(hash, user); changePasswordErr != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "message":        "Failed to change password",
                        "success":        false,
                        "error messsage": changePasswordErr,
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "message": "Your password has been sucessfully changed!",
                "success": true,
        })
        return</span>
}

func (l loginController) VerifyAccessToken(c *gin.Context) <span class="cov8" title="1">{
        c.JSON(http.StatusOK, gin.H{
                "message": "User is authenticated",
                "success": true,
        })
        return
}</span>

func (l loginController) RefreshToken(c *gin.Context) <span class="cov8" title="1">{
        // Accept a refresh token, and return a fresh token if available

        // Get the token off the header
        refreshToken, ok := c.Request.Header["Token"]

        if !ok </span><span class="cov8" title="1">{
                log.Println(`No "token" field in header`)
                c.JSON(http.StatusUnauthorized, gin.H{
                        "message": `No "token" field in header`,
                        "success": false,
                })
                c.AbortWithStatus(http.StatusUnauthorized)
                return
        }</span>

        // Decode/validate it
        <span class="cov8" title="1">token, err := l.loginService.ValidateJWT(refreshToken[0], os.Getenv("JWT_SECRET"))

        if err != nil || !token.Valid </span><span class="cov8" title="1">{
                log.Println(err)
                c.JSON(http.StatusUnauthorized, gin.H{
                        "message": err,
                        "success": false,
                })
                c.AbortWithStatus(http.StatusUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">if claims, ok := l.loginService.MapJWTClaims(*token); ok </span><span class="cov8" title="1">{
                // Check if refresh
                if claims["type"] != "refresh" </span><span class="cov8" title="1">{
                        log.Println("Must provide refresh token")
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "message": "Must provide refresh token",
                                "success": false,
                        })
                        c.AbortWithStatus(http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov8" title="1">var delegations models.Delegations

                // Get refresh token from DB
                delegations, err = l.loginService.FindRefreshToken(claims["sub"].(float64), delegations)

                if err != nil </span><span class="cov8" title="1">{
                        log.Println(err)
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "message": err,
                                "success": false,
                        })
                        c.AbortWithStatus(http.StatusUnauthorized)
                        return
                }</span>

                // Check that they match -&gt; invalidate the token if so and require user to reauthenticate
                <span class="cov8" title="1">if delegations.RefreshToken != refreshToken[0] </span><span class="cov8" title="1">{
                        log.Println("Invalid refresh token was used - must authenticate again")
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "message": "Invalid refresh token was used - must authenticate again",
                                "success": false,
                        })
                        c.AbortWithStatus(http.StatusUnauthorized)

                        // Delete the refresh token from db -&gt; user will have to reauthenticate
                        // User will have access for rest of life of access token but no longer
                        err = l.loginService.DeleteRefreshToken(delegations)

                        if err != nil </span><span class="cov8" title="1">{
                                log.Println("Could not delete token")
                                c.JSON(http.StatusUnauthorized, gin.H{
                                        "message": "Could not delete refresh token from db",
                                        "success": false,
                                })
                                c.AbortWithStatus(http.StatusUnauthorized)
                        }</span>
                        <span class="cov8" title="1">return</span>
                }

                // They do match so it's valid
                <span class="cov8" title="1">accessExpire, refreshExpire := l.loginService.GenerateExpiresJWT()

                // generate the access token
                accessTokenClaims := jwt.MapClaims{
                        "sub":  delegations.ID,
                        "exp":  accessExpire,
                        "type": "access",
                }
                accessToken, err := l.loginService.GenerateJWT(jwt.SigningMethodHS256, accessTokenClaims, os.Getenv("JWT_SECRET"))

                if err != nil </span><span class="cov8" title="1">{
                        log.Println(err)
                        c.JSON(http.StatusBadRequest, gin.H{
                                "error":   "Failed to create access token",
                                "success": false,
                        })
                        return
                }</span>

                // generate the refreshToken
                <span class="cov8" title="1">refreshTokenClaims := jwt.MapClaims{
                        "sub":  delegations.ID,
                        "exp":  refreshExpire,
                        "type": "refresh",
                }
                refreshToken, err := l.loginService.GenerateJWT(jwt.SigningMethodHS256, refreshTokenClaims, os.Getenv("JWT_SECRET"))

                if err != nil </span><span class="cov8" title="1">{
                        log.Println(err)
                        c.JSON(http.StatusBadRequest, gin.H{
                                "error":   "Failed to create refresh token",
                                "success": false,
                        })
                        return
                }</span>

                // Save the code
                <span class="cov8" title="1">err = l.loginService.SaveRefreshToken(delegations.UsersID, refreshToken, delegations)

                if err != nil </span><span class="cov8" title="1">{
                        log.Println(err)
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "message": "Failed to save refresh token to DB",
                                "success": false,
                        })
                        return
                }</span>

                // Send the access/refresh token
                <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                        "message":       "Token refresh success",
                        "access_token":  accessToken,
                        "refresh_token": refreshToken,
                        "success":       true,
                })</span>

        } else<span class="cov8" title="1"> {
                log.Println("Could not map JWT Claims")
                c.JSON(http.StatusInternalServerError, gin.H{
                        "message": "Could not map JWT Claims",
                        "success": false,
                })
                c.AbortWithStatus(http.StatusInternalServerError)
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package controllers

import (
        "net/http"
        "strconv"

        "github.com/VolunteerOne/volunteer-one-app/backend/models"
        "github.com/VolunteerOne/volunteer-one-app/backend/service"
        "github.com/gin-gonic/gin"
)

type OrgUsersController interface {
        CreateOrgUser(c *gin.Context)
        ListAllOrgUsers(c *gin.Context)
        FindOrgUser(c *gin.Context)
        UpdateOrgUser(c *gin.Context)
        DeleteOrgUser(c *gin.Context)
}

type orgUsersController struct {
        orgUsersService service.OrgUsersService
}

// Returns the org user controller instantiated in the Router
func NewOrgUsersController(serv service.OrgUsersService) OrgUsersController <span class="cov8" title="1">{
        return orgUsersController{
                orgUsersService: serv,
        }
}</span>

// Create new role tied to a user and organization
func (o orgUsersController) CreateOrgUser(c *gin.Context) <span class="cov8" title="1">{
        var err error

        // Declare a struct for the desired request body
        var body struct {
                UsersId        uint
                OrganizationId uint
                Role           uint
        }

        // Bind struct to context and check for error
        err = c.Bind(&amp;body)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Request body is invalid.",
                })

                return
        }</span>

        // Create orgUser object model, send to next layer
        <span class="cov8" title="1">orgUser := models.OrgUsers{
                UsersID:        body.UsersId,
                OrganizationID: body.OrganizationId,
                Role:           body.Role,
        }

        result, err := o.orgUsersService.CreateOrgUser(orgUser)

        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Could not create new OrgUser.",
                })

                return
        }</span>

        // Respond with success
        <span class="cov8" title="1">c.JSON(http.StatusOK, result)</span>
}

// Lists all members with roles in organizations
func (o orgUsersController) ListAllOrgUsers(c *gin.Context) <span class="cov8" title="1">{
        result, err := o.orgUsersService.ListAllOrgUsers()

        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Could not retrieve organization users.",
                })

                return
        }</span>

        // Return the array of objects
        <span class="cov8" title="1">c.JSON(http.StatusOK, result)</span>
}

// Find a user's organization roles by User ID
func (o orgUsersController) FindOrgUser(c *gin.Context) <span class="cov8" title="1">{
        // Get the userId
        userId64, err := strconv.ParseUint(c.Param("userId"), 10, 64)

        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "userId field must be an unsigned integer.",
                })

                return
        }</span>

        <span class="cov8" title="1">var body struct {
                OrganizationId uint
        }

        // Bind struct to context and check for errors
        err = c.BindJSON(&amp;body)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Request body is invalid.",
                })

                return
        }</span>

        // Get object from the database
        <span class="cov8" title="1">userId := uint(userId64)
        result, err := o.orgUsersService.FindOrgUser(userId, body.OrganizationId)

        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Could not find OrgUser with that userId/orgId.",
                })

                return
        }</span>

        // Return the object
        <span class="cov8" title="1">c.JSON(http.StatusOK, result)</span>
}

func (o orgUsersController) UpdateOrgUser(c *gin.Context) <span class="cov8" title="1">{
        // Get the userId
        userId64, err := strconv.ParseUint(c.Param("userId"), 10, 64)

        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "userId field must be an unsigned integer.",
                })

                return
        }</span>

        // Get updates from the body
        <span class="cov8" title="1">var body struct {
                OrganizationId uint
                Role           uint
        }

        if err := c.Bind(&amp;body); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Request body is invalid.",
                })

                return
        }</span>

        <span class="cov8" title="1">userId := uint(userId64)
        result, err := o.orgUsersService.UpdateOrgUser(userId, body.OrganizationId, body.Role)

        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Could not update OrgUser with that userId/orgId.",
                })

                return
        }</span>

        // Respond
        <span class="cov8" title="1">c.JSON(http.StatusOK, result)</span>
}

func (o orgUsersController) DeleteOrgUser(c *gin.Context) <span class="cov8" title="1">{
        // Get the userId
        userId64, err := strconv.ParseUint(c.Param("userId"), 10, 64)

        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "userId field must be an unsigned integer.",
                })

                return
        }</span>

        <span class="cov8" title="1">var body struct {
                OrganizationId uint
        }

        // Bind struct to context and check for errors
        err = c.Bind(&amp;body)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Request body is invalid.",
                })

                return
        }</span>

        <span class="cov8" title="1">userId := uint(userId64)
        err = o.orgUsersService.DeleteOrgUser(userId, body.OrganizationId)

        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Could not delete OrgUser.",
                })

                return
        }</span>

        // Respond
        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "message": "OrgUser deleted.",
        })</span>

}
</pre>
		
		<pre class="file" id="file4" style="display: none">package controllers

import (
        "net/http"

        "github.com/VolunteerOne/volunteer-one-app/backend/models"
        "github.com/VolunteerOne/volunteer-one-app/backend/service"
        "github.com/gin-gonic/gin"
)

type OrganizationController interface {
        Create(*gin.Context)
        All(*gin.Context)
        One(*gin.Context)
        Update(*gin.Context)
        Delete(*gin.Context)
}

type organizationController struct {
        organizationService service.OrganizationService
}

func NewOrganizationController(s service.OrganizationService) OrganizationController <span class="cov8" title="1">{
        return organizationController{
                organizationService: s,
        }
}</span>

// var organizationModel = new(models.Organization)

// Create ...
func (controller organizationController) Create(c *gin.Context) <span class="cov8" title="1">{
        var err error

        // Declare a struct for the desired request body
        var body struct {
                Name        string
                Description string
                Verified    bool
                Interests   string
        }

        // Bind struct to context and check for error
        err = controller.organizationService.Bind(c, &amp;body)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Request body is invalid",
                })

                return
        }</span>

        // Create the object in the database
        <span class="cov8" title="1">object := models.Organization{
                Name:        body.Name,
                Description: body.Description,
                Verified:    body.Verified,
                Interests:   body.Interests,
        }

        res, err := controller.organizationService.CreateOrganization(object)

        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Creation failed",
                })

                return
        }</span>

        // Respond
        <span class="cov8" title="1">c.JSON(http.StatusOK, res)</span>
}

func (controller organizationController) All(c *gin.Context) <span class="cov8" title="1">{

        // Get objects from database
        orgs, err := controller.organizationService.GetOrganizations()

        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Could not retrieve objects",
                })

                return
        }</span>

        // Return the array of objects
        <span class="cov8" title="1">c.JSON(http.StatusOK, orgs)</span>

}

func (controller organizationController) One(c *gin.Context) <span class="cov8" title="1">{
        // Get the id
        id := c.Param("id")

        // Get object from the database
        org, err := controller.organizationService.GetOrganizationById(id)

        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Could not retrieve object",
                })

                return
        }</span>

        // Return the object
        <span class="cov8" title="1">c.JSON(http.StatusAccepted, org)</span>
}

func (controller organizationController) Update(c *gin.Context) <span class="cov8" title="1">{

        id := c.Param("id")

        org, err := controller.organizationService.GetOrganizationById(id)

        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Could not retrieve object",
                })

                return
        }</span>

        // Get updates from the body
        <span class="cov8" title="1">var body struct {
                Name        string
                Description string
                Verified    bool
                Interests   string
        }

        if err = controller.organizationService.Bind(c, &amp;body); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Request body is invalid",
                })

                return
        }</span>

        <span class="cov8" title="1">org.Name = body.Name
        org.Description = body.Description
        org.Verified = body.Verified
        org.Interests = body.Interests

        // Update the object
        result, err := controller.organizationService.UpdateOrganization(org)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Could not update object",
                })

                return
        }</span>

        // Respond
        <span class="cov8" title="1">c.JSON(http.StatusOK, result)</span>
}

func (controller organizationController) Delete(c *gin.Context) <span class="cov8" title="1">{

        // Get the existing object
        id := c.Param("id")
        org, err := controller.organizationService.GetOrganizationById(id)

        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Could not retrieve object",
                })

                return
        }</span>

        // Delete the object
        <span class="cov8" title="1">err = controller.organizationService.DeleteOrganization(org)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Could not delete object",
                })

                return
        }</span>

        // Respond
        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "message": "Object deleted successfully",
        })</span>

}
</pre>
		
		<pre class="file" id="file5" style="display: none">package controllers

import (
        "net/http"

        "github.com/VolunteerOne/volunteer-one-app/backend/models"
        "github.com/VolunteerOne/volunteer-one-app/backend/service"
        "github.com/gin-gonic/gin"
)

type PostsController interface {
        CreatePost(c *gin.Context)
        DeletePost(c *gin.Context)
        EditPost(c *gin.Context)
        FindPost(c *gin.Context)
        AllPosts(c *gin.Context)
}

type postsController struct {
        postsService service.PostsService
}

func NewPostsController(s service.PostsService) PostsController <span class="cov8" title="1">{
        return postsController{
                postsService: s,
        }
}</span>

var postsModel = new(models.Posts)

func (controller postsController) CreatePost(c *gin.Context) <span class="cov8" title="1">{
        var err error
        var body struct {
                Handle          string
                PostDescription string
        }
        err = controller.postsService.Bind(c, &amp;body)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Request body is invalid",
                })
                return
        }</span>

        <span class="cov8" title="1">object := models.Posts{
                Handle:          body.Handle,
                PostDescription: body.PostDescription,
        }

        result, err := controller.postsService.CreatePost(object)

        _ = result

        if err != nil </span><span class="cov8" title="1">{

                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Creation failed",
                })

                return
        }</span>

        // Respond
        <span class="cov8" title="1">c.JSON(http.StatusOK, object)</span>
}

func (controller postsController) DeletePost(c *gin.Context) <span class="cov8" title="1">{
        id := c.Param("id")

        result, err := controller.postsService.FindPost(id)

        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Could not retrieve object",
                })

                return
        }</span>

        // Delete the object
        <span class="cov8" title="1">err1 := controller.postsService.DeletePost(result)

        if err1 != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Could not delete object",
                })

                return
        }</span>

        // Respond
        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "message": "Object deleted successfully",
        })</span>
}

func (controller postsController) EditPost(c *gin.Context) <span class="cov8" title="1">{
        id := c.Param("id")
        result, err1 := controller.postsService.FindPost(id)

        if err1 != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Could not retrieve object",
                })
                return
        }</span>

        <span class="cov8" title="1">var err error
        var body struct {
                PostDescription string
        }
        err = controller.postsService.Bind(c, &amp;body)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Request body is invalid",
                })
                return
        }</span>

        <span class="cov8" title="1">result.PostDescription = body.PostDescription

        results1, err := controller.postsService.EditPost(result)

        if err != nil </span><span class="cov8" title="1">{

                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Creation failed",
                })

                return
        }</span>

        // Respond
        <span class="cov8" title="1">c.JSON(http.StatusOK, results1)</span>
}

func (controller postsController) FindPost(c *gin.Context) <span class="cov8" title="1">{
        id := c.Param("id")

        result, err1 := controller.postsService.FindPost(id)

        if err1 != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Could not retrieve object",
                })

                return
        }</span>

        // Return the object
        <span class="cov8" title="1">c.JSON(http.StatusOK, result)</span>
}

func (controller postsController) AllPosts(c *gin.Context) <span class="cov8" title="1">{
        // Get object from the database
        posts, err := controller.postsService.AllPosts()

        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Could not retrieve objects",
                })

                return
        }</span>

        // Return the array of objects
        <span class="cov8" title="1">c.JSON(http.StatusOK, posts)</span>
}

type CommentsController interface {
        CreateComment(c *gin.Context)
        DeleteComment(c *gin.Context)
        EditComment(c *gin.Context)
        FindComment(c *gin.Context)
        AllComments(c *gin.Context)
}

type commentsController struct {
        commentsService service.CommentsService
}

func NewCommentsController(s service.CommentsService) CommentsController <span class="cov8" title="1">{
        return commentsController{
                commentsService: s,
        }
}</span>

var CommentsModel = new(models.Comments)

func (controller commentsController) CreateComment(c *gin.Context) <span class="cov8" title="1">{
        var err error
        var body struct {
                PostsID            uint
                Handle             string
                CommentDescription string
        }
        err = controller.commentsService.Bind(c, &amp;body)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Request body is invalid",
                })
                return
        }</span>

        <span class="cov8" title="1">object := models.Comments{
                PostsID:            body.PostsID,
                Handle:             body.Handle,
                CommentDescription: body.CommentDescription,
        }

        result, err := controller.commentsService.CreateComment(object)

        _ = result

        if err != nil </span><span class="cov8" title="1">{

                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Creation failed",
                })

                return
        }</span>

        // Respond
        <span class="cov8" title="1">c.JSON(http.StatusOK, object)</span>
}

func (controller commentsController) DeleteComment(c *gin.Context) <span class="cov8" title="1">{
        id := c.Param("id")

        result, err := controller.commentsService.FindComment(id)

        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Could not retrieve object",
                })

                return
        }</span>

        // Delete the object
        <span class="cov8" title="1">err1 := controller.commentsService.DeleteComment(result)

        if err1 != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Could not delete object",
                })

                return
        }</span>

        // Respond
        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "message": "Object deleted successfully",
        })</span>
}

func (controller commentsController) EditComment(c *gin.Context) <span class="cov8" title="1">{
        id := c.Param("id")
        result, err1 := controller.commentsService.FindComment(id)

        if err1 != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Could not retrieve object",
                })

                return
        }</span>

        <span class="cov8" title="1">var err error
        var body struct {
                CommentDescription string
        }
        err = controller.commentsService.Bind(c, &amp;body)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Request body is invalid",
                })
                return
        }</span>

        <span class="cov8" title="1">result.CommentDescription = body.CommentDescription

        results1, err := controller.commentsService.EditComment(result)

        if err != nil </span><span class="cov8" title="1">{

                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Creation failed",
                })

                return
        }</span>

        // Respond
        <span class="cov8" title="1">c.JSON(http.StatusOK, results1)</span>
}

func (controller commentsController) FindComment(c *gin.Context) <span class="cov8" title="1">{
        id := c.Param("id")

        result, err1 := controller.commentsService.FindComment(id)

        if err1 != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Could not retrieve object",
                })

                return
        }</span>

        // Return the object
        <span class="cov8" title="1">c.JSON(http.StatusOK, result)</span>
}

func (controller commentsController) AllComments(c *gin.Context) <span class="cov8" title="1">{
        // Get object from the database
        comments, err := controller.commentsService.AllComments()

        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Could not retrieve objects",
                })

                return
        }</span>

        // Return the array of objects
        <span class="cov8" title="1">c.JSON(http.StatusOK, comments)</span>
}

type LikesController interface {
        CreateLike(c *gin.Context)
        DeleteLike(c *gin.Context)
        FindLike(c *gin.Context)
        AllLikes(c *gin.Context)
        GetLikes(c *gin.Context)
}

type likesController struct {
        likesService service.LikesService
}

func NewLikesController(s service.LikesService) LikesController <span class="cov8" title="1">{
        return likesController{
                likesService: s,
        }
}</span>

var LikesModel = new(models.Likes)

func (controller likesController) CreateLike(c *gin.Context) <span class="cov8" title="1">{
        var err error
        var body struct {
                Handle  string
                PostsID uint
        }
        err = controller.likesService.Bind(c, &amp;body)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Request body is invalid",
                })
                return
        }</span>

        <span class="cov8" title="1">object := models.Likes{
                Handle:  body.Handle,
                PostsID: body.PostsID,
        }

        result, err := controller.likesService.CreateLike(object)

        _ = result

        if err != nil </span><span class="cov8" title="1">{

                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Creation failed",
                })

                return
        }</span>

        // Respond
        <span class="cov8" title="1">c.JSON(http.StatusOK, object)</span>
}

func (controller likesController) DeleteLike(c *gin.Context) <span class="cov8" title="1">{
        id := c.Param("id")

        result, err := controller.likesService.FindLike(id)

        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Could not retrieve object",
                })

                return
        }</span>

        // Delete the object
        <span class="cov8" title="1">err1 := controller.likesService.DeleteLike(result)

        if err1 != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Could not delete object",
                })

                return
        }</span>

        // Respond
        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "message": "Object deleted successfully",
        })</span>
}

func (controller likesController) FindLike(c *gin.Context) <span class="cov8" title="1">{
        id := c.Param("id")

        result, err1 := controller.likesService.FindLike(id)

        if err1 != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Could not retrieve object",
                })

                return
        }</span>

        // Return the object
        <span class="cov8" title="1">c.JSON(http.StatusOK, result)</span>
}

func (controller likesController) AllLikes(c *gin.Context) <span class="cov8" title="1">{
        // Get object from the database
        likes, err := controller.likesService.AllLikes()

        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Could not retrieve objects",
                })

                return
        }</span>

        // Return the array of objects
        <span class="cov8" title="1">c.JSON(http.StatusOK, likes)</span>
}

func (controller likesController) GetLikes(c *gin.Context) <span class="cov8" title="1">{
        id := c.Param("id")
        // Get object from the database
        likes, err := controller.likesService.GetLikes(id)

        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Could not retrieve objects",
                })

                return
        }</span>

        // Return the array of objects
        <span class="cov8" title="1">c.JSON(http.StatusOK, likes)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package controllers

import (
        "net/http"

        "github.com/VolunteerOne/volunteer-one-app/backend/models"
        "github.com/VolunteerOne/volunteer-one-app/backend/service"
        "github.com/gin-gonic/gin"
)

type UsersController interface {
        Create(c *gin.Context)
        One(c *gin.Context)
        Update(c *gin.Context)
        Delete(c *gin.Context)
}

type usersController struct {
        usersService service.UsersService
}

func NewUsersController(s service.UsersService) UsersController <span class="cov8" title="1">{
        return usersController{
                usersService: s,
        }
}</span>

var usersModel = new(models.Users)

// Create ...
func (controller usersController) Create(c *gin.Context) <span class="cov8" title="1">{
        var err error

        // db := database.GetDatabase()

        // Declare a struct for the desired request body
        var body struct {
                Id       uint
                Handle   string
                Email    string
                Password string
                // birthdate datatypes.Date `gorm: "NOT NULL"`
                Birthdate string
                FirstName string
                LastName  string
                // profilePic mediumblob,
                Interests string
                Verified  uint
        }

        // Bind struct to context and check for error
        err = c.Bind(&amp;body)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Request body is invalid",
                })

                return
        }</span>

        <span class="cov8" title="1">hash, err := controller.usersService.HashPassword([]byte(body.Password))

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Failed to hash password",
                })

                return
        }</span>

        // Create the object in the database
        <span class="cov8" title="1">object := models.Users{
                Handle:    body.Handle,
                Email:     body.Email,
                Password:  string(hash),
                Birthdate: body.Birthdate,
                FirstName: body.FirstName,
                LastName:  body.LastName,
                // ProfilePic: body.profilePic,
                Interests: body.Interests,
                Verified:  body.Verified,
        }

        result, err := controller.usersService.CreateUser(object)

        _ = result

        if err != nil </span><span class="cov0" title="0">{

                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Creation failed",
                })

                return
        }</span>

        // Respond
        <span class="cov8" title="1">c.JSON(http.StatusOK, object)</span>
}

func (controller usersController) One(c *gin.Context) <span class="cov0" title="0">{

        // Get the id
        id := c.Param("id")

        // Get object from the database
        var object models.Users
        result, err := controller.usersService.OneUser(id, object)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Could not retrieve object",
                })

                return
        }</span>

        // Return the object
        <span class="cov0" title="0">c.JSON(http.StatusOK, result)</span>
}

func (controller usersController) Update(c *gin.Context) <span class="cov0" title="0">{

        // Get the existing object
        id := c.Param("id")
        var object models.Users

        result, err := controller.usersService.OneUser(id, object)

        _ = result

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Could not retrieve object",
                })

                return
        }</span>

        // Get updates from the body
        <span class="cov0" title="0">var body struct {
                Id       uint
                Handle   string
                Email    string
                Password string
                // birthdate datatypes.Date `gorm: "NOT NULL"`
                Birthdate string
                FirstName string
                LastName  string
                // profilePic mediumblob,
                Interests string
                Verified  uint
        }
        if err := c.Bind(&amp;body); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Request body is invalid",
                })

                return
        }</span>

        <span class="cov0" title="0">object.Handle = body.Handle
        object.Email = body.Email
        object.Password = body.Password
        object.Birthdate = body.Birthdate
        object.FirstName = body.FirstName
        object.LastName = body.LastName
        // object.ProfilePic = body.profilePic
        object.Interests = body.Interests
        object.Verified = body.Verified

        // Update the object

        result1, err := controller.usersService.UpdateUser(object)

        _ = result1

        if err != nil </span><span class="cov0" title="0">{
                // result = db.Save(&amp;object)
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Could not update object",
                })

                return
        }</span>

        // Respond
        <span class="cov0" title="0">c.JSON(http.StatusOK, object)</span>

}

func (controller usersController) Delete(c *gin.Context) <span class="cov8" title="1">{

        // Get the existing object
        id := c.Param("id")
        var object models.Users
        result, err := controller.usersService.OneUser(id, object)

        _ = result

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Could not retrieve object",
                })

                return
        }</span>

        // Delete the object
        <span class="cov8" title="1">result1, err := controller.usersService.DeleteUser(object)

        _ = result1

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Could not delete object",
                })

                return
        }</span>

        // Respond
        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "message": "Object deleted successfully",
        })</span>

}
</pre>
		
		<pre class="file" id="file7" style="display: none">package repository

import (
        "errors"

        "github.com/VolunteerOne/volunteer-one-app/backend/models"
        "gorm.io/gorm"
)

type EventRepository interface {
        CreateEvent(models.Event) (models.Event, error)
        GetEvents() ([]models.Event, error)
        GetEventById(string) (models.Event, error)
        UpdateEvent(models.Event) (models.Event, error)
        DeleteEvent(models.Event) error
}

type eventRepository struct {
        DB *gorm.DB
}

// CreateEvent implements EventRepository
func (r eventRepository) CreateEvent(event models.Event) (models.Event, error) <span class="cov8" title="1">{
        result := r.DB.Create(&amp;event)
        r.DB.Preload("Organization").Find(&amp;event)

        if result.Error != nil </span><span class="cov8" title="1">{
                return models.Event{}, errors.New("creation failed")
        }</span>

        <span class="cov8" title="1">return event, nil</span>
}

// DeleteEvent implements EventRepository
func (r eventRepository) DeleteEvent(event models.Event) error <span class="cov8" title="1">{
        result := r.DB.Where("ID = ?", event.ID).Delete(&amp;event)
        if result.Error != nil </span><span class="cov8" title="1">{
                return errors.New("deletion failed")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetEventById implements EventRepository
func (r eventRepository) GetEventById(id string) (models.Event, error) <span class="cov8" title="1">{
        var event models.Event

        result := r.DB.First(&amp;event, id)
        r.DB.Preload("Organization").Find(&amp;event)

        if result.Error != nil </span><span class="cov8" title="1">{
                return models.Event{}, errors.New("get failed")
        }</span>

        <span class="cov8" title="1">return event, nil</span>
}

// GetEvents implements EventRepository
func (r eventRepository) GetEvents() ([]models.Event, error) <span class="cov8" title="1">{
        var events []models.Event
        result := r.DB.Find(&amp;events)
        r.DB.Preload("Organization").Find(&amp;events)

        if result.Error != nil </span><span class="cov8" title="1">{
                return []models.Event{}, errors.New("get failed")
        }</span>

        <span class="cov8" title="1">return events, nil</span>
}

// UpdateEvent implements EventRepository
func (r eventRepository) UpdateEvent(event models.Event) (models.Event, error) <span class="cov8" title="1">{
        result := r.DB.Save(&amp;event)
        r.DB.Preload("Organization").Find(&amp;event)

        if result.Error != nil </span><span class="cov8" title="1">{
                return models.Event{}, errors.New("update failed")
        }</span>

        <span class="cov8" title="1">return event, nil</span>
}

func NewEventRepository(db *gorm.DB) EventRepository <span class="cov8" title="1">{
        return eventRepository{
                DB: db,
        }
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package repository

import (
        "errors"

        "github.com/VolunteerOne/volunteer-one-app/backend/models"
        "gorm.io/gorm"
)

type FriendRepository interface {
        CreateFriend(friend models.Friend) (models.Friend, error)
        AcceptFriend(friend models.Friend) (models.Friend, error)
        RejectFriend(friend models.Friend) error
        OneFriend(id string) (models.Friend, error)
        GetFriends() ([]models.Friend, error)
}

type friendRepository struct {
        DB *gorm.DB
}

func NewFriendRepository(db *gorm.DB) FriendRepository <span class="cov8" title="1">{
        return friendRepository{
                DB: db,
        }
}</span>

func (f friendRepository) CreateFriend(friend models.Friend) (models.Friend, error) <span class="cov8" title="1">{

        err := f.DB.Create(&amp;friend).Error

        return friend, err
}</span>

func (f friendRepository) AcceptFriend(friend models.Friend) (models.Friend, error) <span class="cov8" title="1">{
        result := f.DB.Save(&amp;friend)

        if result.Error != nil </span><span class="cov8" title="1">{
                return models.Friend{}, errors.New("could not update friend")
        }</span>

        <span class="cov8" title="1">return friend, nil</span>
}

func (f friendRepository) RejectFriend(friend models.Friend) error <span class="cov8" title="1">{
        // more explicit for testing -&gt; f.DB.Delete(&amp;friend) would do the same but it trickier to test
        result := f.DB.Where("ID = ?", friend.ID).Delete(&amp;friend)
        if result.Error != nil </span><span class="cov8" title="1">{
                return errors.New("could not delete friend")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (f friendRepository) OneFriend(id string) (models.Friend, error) <span class="cov8" title="1">{
        var friend models.Friend
        result := f.DB.First(&amp;friend, id)

        if result.Error != nil </span><span class="cov8" title="1">{
                return models.Friend{}, errors.New("could not retrieve friend")
        }</span>

        <span class="cov8" title="1">return friend, nil</span>
}

func (f friendRepository) GetFriends() ([]models.Friend, error) <span class="cov8" title="1">{
        var friends []models.Friend
        result := f.DB.Find(&amp;friends)

        if result.Error != nil </span><span class="cov8" title="1">{
                return []models.Friend{}, errors.New("could not retrieve friends")
        }</span>

        <span class="cov8" title="1">return friends, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package repository

import (
        "log"

        "github.com/VolunteerOne/volunteer-one-app/backend/models"
        "github.com/google/uuid"
        "gorm.io/gorm"
)

type LoginRepository interface {
        FindUserFromEmail(string, models.Users) (models.Users, error)
        SaveResetCodeToUser(uuid.UUID, models.Users) error
        ChangePassword([]byte, models.Users) error
        SaveRefreshToken(uint, string, models.Delegations) error
        FindRefreshToken(float64, models.Delegations) (models.Delegations, error)
        DeleteRefreshToken(models.Delegations) error
}

type loginRepository struct {
        DB *gorm.DB
}

// Instantiated in router.go
func NewLoginRepository(db *gorm.DB) LoginRepository <span class="cov8" title="1">{
        return loginRepository{
                DB: db,
        }
}</span>

// Attempts to find the first entry with the email in the DB
func (l loginRepository) FindUserFromEmail(email string, user models.Users) (models.Users, error) <span class="cov8" title="1">{
        log.Println("[LoginRepository] Find Email...")

        // User will be populated with the content if possible
        err := l.DB.Where("email = ?", email).First(&amp;user).Error

        return user, err
}</span>

// Saves a reset code for the user in the DB
func (l loginRepository) SaveResetCodeToUser(resetCode uuid.UUID, user models.Users) error <span class="cov8" title="1">{
        log.Println("[LoginRepository] Save Reset Code...")
        // Update the user's reset code and expiry time
        user.ResetCode = resetCode
        // Save the changes to the database
        return l.DB.Save(&amp;user).Error
}</span>

func (l loginRepository) ChangePassword(newPassword []byte, user models.Users) error <span class="cov8" title="1">{
        log.Println("Entering ChangePassword repository")

        user.Password = string(newPassword)
        return l.DB.Save(&amp;user).Error
}</span>

func (l loginRepository) SaveRefreshToken(userid uint, refreshToken string, deleg models.Delegations) error <span class="cov8" title="1">{
        log.Println("[LoginRepository] Save Refresh Token...")

        deleg.UsersID = userid
        deleg.RefreshToken = refreshToken

        err := l.DB.Save(&amp;deleg).Error

        if err != nil </span><span class="cov8" title="1">{
                log.Println("[LoginRepository:SaveRefreshToken] Have To Update Token Only...")
                return l.DB.Model(&amp;deleg).Where("users_id = ?", userid).Update("refresh_token", refreshToken).Error
        }</span>

        <span class="cov8" title="1">return err</span>
}

func (l loginRepository) FindRefreshToken(userid float64, deleg models.Delegations) (models.Delegations, error) <span class="cov8" title="1">{
        log.Println("[LoginRepository] Find Refresh Token...")

        err := l.DB.Where("users_id = ?", userid).First(&amp;deleg).Error

        return deleg, err
}</span>

func (l loginRepository) DeleteRefreshToken(deleg models.Delegations) error <span class="cov8" title="1">{
        log.Println("[LoginRepository] Delete Refresh Token...")

        return l.DB.Unscoped().Delete(&amp;deleg).Error
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package repository

import (
        "log"
        "strconv"

        "github.com/VolunteerOne/volunteer-one-app/backend/models"
        "gorm.io/gorm"
)

type OrgUsersRepository interface {
        CreateOrgUser(models.OrgUsers) (models.OrgUsers, error)
        ListAllOrgUsers() ([]models.OrgUsers, error)
        FindOrgUser(uint, uint) (models.OrgUsers, error)
        UpdateOrgUser(uint, uint, uint) (models.OrgUsers, error)
        DeleteOrgUser(uint, uint) error
}

type orgUsersRepository struct {
        DB *gorm.DB
}

// Instantiated in router.go
func NewOrgUsersRepository(db *gorm.DB) OrgUsersRepository <span class="cov8" title="1">{
        return orgUsersRepository{
                DB: db,
        }
}</span>

// Generates new user role for an organization
func (o orgUsersRepository) CreateOrgUser(orgUser models.OrgUsers) (models.OrgUsers, error) <span class="cov8" title="1">{
        log.Println("[orgsUsersRepository] Creating OrgUser entry...")

        err := o.DB.Create(&amp;orgUser).Error
        o.DB.Preload("Users").Find(&amp;orgUser)
        o.DB.Preload("Organization").Find(&amp;orgUser)

        return orgUser, err
}</span>

// Lists all members with roles in organizations
func (o orgUsersRepository) ListAllOrgUsers() ([]models.OrgUsers, error) <span class="cov8" title="1">{
        log.Println("[orgsUsersRepository] Listing all OrgUser rows...")

        var orgUsers []models.OrgUsers

        err := o.DB.Find(&amp;orgUsers).Error

        o.DB.Preload("Users").Find(&amp;orgUsers)
        o.DB.Preload("Organization").Find(&amp;orgUsers)

        return orgUsers, err
}</span>

// Finds a user with a role in an organization by User ID
func (o orgUsersRepository) FindOrgUser(userId uint, orgId uint) (models.OrgUsers, error) <span class="cov8" title="1">{
        userIdStr := strconv.FormatUint(uint64(userId), 10)
        orgIdStr := strconv.FormatUint(uint64(orgId), 10)

        log.Println("[orgsUsersRepository] Finding OrgUser entry with ID (" +
                userIdStr + ") in Org ID (" + orgIdStr + ")...")

        var orgUser models.OrgUsers

        err := o.DB.Where("users_id = ? AND organization_id = ?", userId, orgId).First(&amp;orgUser).Error

        o.DB.Preload("Users").Find(&amp;orgUser)
        o.DB.Preload("Organization").Find(&amp;orgUser)

        return orgUser, err
}</span>

// Updates role for existing OrgUser object by ID
func (o orgUsersRepository) UpdateOrgUser(userId uint, orgId uint, role uint) (models.OrgUsers, error) <span class="cov8" title="1">{
        userIdStr := strconv.FormatUint(uint64(userId), 10)
        orgIdStr := strconv.FormatUint(uint64(orgId), 10)

        log.Println("[orgsUsersRepository] Updating OrgUser entry for ID (" +
                userIdStr + ") in Org ID (" + orgIdStr + ")...")

        var orgUser models.OrgUsers

        err := o.DB.Where("users_id = ? AND organization_id = ?", userId, orgId).Find(&amp;orgUser).Error

        if err != nil </span><span class="cov8" title="1">{
                return orgUser, err
        }</span>

        <span class="cov8" title="1">orgUser.Role = role

        err = o.DB.Save(&amp;orgUser).Error

        o.DB.Preload("Users").Find(&amp;orgUser)
        o.DB.Preload("Organization").Find(&amp;orgUser)

        return orgUser, err</span>
}

// Delete existing OrgUser object by ID
func (o orgUsersRepository) DeleteOrgUser(userId uint, orgId uint) error <span class="cov8" title="1">{
        userIdStr := strconv.FormatUint(uint64(userId), 10)
        orgIdStr := strconv.FormatUint(uint64(orgId), 10)

        log.Println("[orgsUsersRepository] Deleting OrgUser entry for user ID (" +
                userIdStr + ") in Org ID (" + orgIdStr + ")...")

        var orgUser models.OrgUsers
        err := o.DB.Where("users_id = ? AND organization_id = ?", userId, orgId).Find(&amp;orgUser).Error

        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">err = o.DB.Where("users_id = ? AND organization_id = ?").Delete(&amp;orgUser).Error

        return err</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package repository

import (
        "errors"

        "github.com/VolunteerOne/volunteer-one-app/backend/models"
        "gorm.io/gorm"
)

type OrganizationRepository interface {
        CreateOrganization(models.Organization) (models.Organization, error)
        GetOrganizations() ([]models.Organization, error)
        GetOrganizationById(string) (models.Organization, error)
        UpdateOrganization(models.Organization) (models.Organization, error)
        DeleteOrganization(models.Organization) error
}

type organizationRepository struct {
        DB *gorm.DB
}

func NewOrganizationRepository(db *gorm.DB) OrganizationRepository <span class="cov8" title="1">{
        return organizationRepository{
                DB: db,
        }
}</span>

func (r organizationRepository) CreateOrganization(org models.Organization) (models.Organization, error) <span class="cov8" title="1">{
        result := r.DB.Create(&amp;org)

        if result.Error != nil </span><span class="cov8" title="1">{
                return models.Organization{}, errors.New("creation Failed")
        }</span>

        <span class="cov8" title="1">return org, nil</span>
}

func (r organizationRepository) GetOrganizations() ([]models.Organization, error) <span class="cov8" title="1">{
        var orgs []models.Organization
        result := r.DB.Find(&amp;orgs)

        if result.Error != nil </span><span class="cov8" title="1">{
                return []models.Organization{}, errors.New("could not retrieve organizations")
        }</span>

        <span class="cov8" title="1">return orgs, nil</span>
}

func (r organizationRepository) GetOrganizationById(id string) (models.Organization, error) <span class="cov8" title="1">{
        var org models.Organization

        result := r.DB.First(&amp;org, id)

        if result.Error != nil </span><span class="cov8" title="1">{
                return models.Organization{}, errors.New("could not retrieve organization")
        }</span>

        <span class="cov8" title="1">return org, nil</span>
}

func (r organizationRepository) UpdateOrganization(org models.Organization) (models.Organization, error) <span class="cov8" title="1">{
        result := r.DB.Save(&amp;org)

        if result.Error != nil </span><span class="cov8" title="1">{
                return models.Organization{}, errors.New("could not update organization")
        }</span>

        <span class="cov8" title="1">return org, nil</span>
}

func (r organizationRepository) DeleteOrganization(org models.Organization) error <span class="cov8" title="1">{
        result := r.DB.Where("ID = ?", org.ID).Delete(&amp;org)
        if result.Error != nil </span><span class="cov8" title="1">{
                return errors.New("could not delete organization")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package repository

import (
        "errors"

        "github.com/VolunteerOne/volunteer-one-app/backend/models"
        "gorm.io/gorm"
)

type PostsRepository interface {
        CreatePost(post models.Posts) (models.Posts, error)
        DeletePost(post models.Posts) error
        EditPost(post models.Posts) (models.Posts, error)
        FindPost(id string) (models.Posts, error)
        AllPosts() ([]models.Posts, error)
}
type CommentsRepository interface {
        CreateComment(Comment models.Comments) (models.Comments, error)
        DeleteComment(Comment models.Comments) error
        EditComment(Comment models.Comments) (models.Comments, error)
        FindComment(id string) (models.Comments, error)
        AllComments() ([]models.Comments, error)
}

type LikesRepository interface {
        CreateLike(Like models.Likes) (models.Likes, error)
        DeleteLike(Like models.Likes) error
        FindLike(id string) (models.Likes, error)
        AllLikes() ([]models.Likes, error)
        GetLikes(id string) (int64, error)
}

type postsRepository struct {
        DB *gorm.DB
}

func NewPostsRepository(db *gorm.DB) PostsRepository <span class="cov8" title="1">{
        return postsRepository{
                DB: db,
        }
}</span>

type commentsRepository struct {
        DB *gorm.DB
}

func NewCommentsRepository(db *gorm.DB) CommentsRepository <span class="cov8" title="1">{
        return commentsRepository{
                DB: db,
        }
}</span>

type likesRepository struct {
        DB *gorm.DB
}

func NewLikesRepository(db *gorm.DB) LikesRepository <span class="cov8" title="1">{
        return likesRepository{
                DB: db,
        }
}</span>

func (r postsRepository) CreatePost(post models.Posts) (models.Posts, error) <span class="cov8" title="1">{

        err := r.DB.Create(&amp;post).Error

        return post, err
}</span>

func (r postsRepository) DeletePost(post models.Posts) error <span class="cov8" title="1">{

        result := r.DB.Where("ID = ?", post.ID).Delete(&amp;post)
        if result.Error != nil </span><span class="cov8" title="1">{
                return errors.New("could not delete post")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r postsRepository) EditPost(post models.Posts) (models.Posts, error) <span class="cov8" title="1">{

        result := r.DB.Save(&amp;post)
        if result.Error != nil </span><span class="cov8" title="1">{
                return models.Posts{}, errors.New("could not update post")
        }</span>

        <span class="cov8" title="1">return post, nil</span>
}

func (r postsRepository) FindPost(id string) (models.Posts, error) <span class="cov8" title="1">{
        var post models.Posts
        result := r.DB.Find(&amp;post, id)

        if result.Error != nil </span><span class="cov8" title="1">{
                return models.Posts{}, errors.New("could not retrive post")
        }</span>
        <span class="cov8" title="1">return post, nil</span>
}

func (r postsRepository) AllPosts() ([]models.Posts, error) <span class="cov8" title="1">{
        var posts []models.Posts
        result := r.DB.Find(&amp;posts)

        if result.Error != nil </span><span class="cov8" title="1">{
                return []models.Posts{}, errors.New("could not retrive post")
        }</span>
        <span class="cov8" title="1">return posts, nil</span>
}

func (r commentsRepository) CreateComment(comment models.Comments) (models.Comments, error) <span class="cov8" title="1">{

        err := r.DB.Create(&amp;comment).Error

        return comment, err
}</span>

func (r commentsRepository) DeleteComment(comment models.Comments) error <span class="cov8" title="1">{

        result := r.DB.Where("ID = ?", comment.ID).Delete(&amp;comment)
        if result.Error != nil </span><span class="cov8" title="1">{
                return errors.New("could not delete comment")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r commentsRepository) EditComment(comment models.Comments) (models.Comments, error) <span class="cov8" title="1">{

        result := r.DB.Save(&amp;comment)
        if result.Error != nil </span><span class="cov8" title="1">{
                return models.Comments{}, errors.New("could not update comment")
        }</span>

        <span class="cov8" title="1">return comment, nil</span>
}

func (r commentsRepository) FindComment(id string) (models.Comments, error) <span class="cov8" title="1">{
        var comment models.Comments
        result := r.DB.Find(&amp;comment, id)

        if result.Error != nil </span><span class="cov8" title="1">{
                return models.Comments{}, errors.New("could not retrive comment")
        }</span>
        <span class="cov8" title="1">return comment, nil</span>
}

func (r commentsRepository) AllComments() ([]models.Comments, error) <span class="cov8" title="1">{
        var comments []models.Comments
        result := r.DB.Find(&amp;comments)

        if result.Error != nil </span><span class="cov8" title="1">{
                return []models.Comments{}, errors.New("could not retrive comment")
        }</span>
        <span class="cov8" title="1">return comments, nil</span>
}

func (r likesRepository) CreateLike(like models.Likes) (models.Likes, error) <span class="cov8" title="1">{

        err := r.DB.Create(&amp;like).Error

        return like, err
}</span>

func (r likesRepository) DeleteLike(like models.Likes) error <span class="cov8" title="1">{

        result := r.DB.Where("ID = ?", like.ID).Delete(&amp;like)
        if result.Error != nil </span><span class="cov8" title="1">{
                return errors.New("could not delete like")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r likesRepository) FindLike(id string) (models.Likes, error) <span class="cov8" title="1">{
        var likes models.Likes
        result := r.DB.Find(&amp;likes, id)

        if result.Error != nil </span><span class="cov8" title="1">{
                return models.Likes{}, errors.New("could not retrive like")
        }</span>
        <span class="cov8" title="1">return likes, nil</span>
}

func (r likesRepository) AllLikes() ([]models.Likes, error) <span class="cov8" title="1">{
        var likes []models.Likes
        result := r.DB.Find(&amp;likes)

        if result.Error != nil </span><span class="cov8" title="1">{
                return []models.Likes{}, errors.New("could not retrive like")
        }</span>
        <span class="cov8" title="1">return likes, nil</span>
}

func (r likesRepository) GetLikes(id string) (int64, error) <span class="cov8" title="1">{
        var likes models.Likes
        var count int64
        result := r.DB.Where("PostID=?", id).Find(&amp;likes)

        if result.Error != nil </span><span class="cov8" title="1">{
                return 0, errors.New("could not find likes")
        }</span>

        <span class="cov8" title="1">result = result.Count(&amp;count)

        if result.Error != nil </span><span class="cov8" title="1">{
                return count, errors.New("could not retrive like")
        }</span>
        <span class="cov8" title="1">return count, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package repository

import (
        "log"

        "github.com/VolunteerOne/volunteer-one-app/backend/models"
        "gorm.io/gorm"
)

type UsersRepository interface {
        CreateUser(user models.Users) (models.Users, error)
        OneUser(id string, user models.Users) (models.Users, error)
        UpdateUser(user models.Users) (models.Users, error)
        DeleteUser(user models.Users) (models.Users, error)
}

type usersRepository struct {
        DB *gorm.DB
}

func NewUsersRepository(db *gorm.DB) UsersRepository <span class="cov8" title="1">{
        return usersRepository{
                DB: db,
        }
}</span>

// Add the user to the DB
func (u usersRepository) CreateUser(user models.Users) (models.Users, error) <span class="cov8" title="1">{
        log.Println("[UsersRepository] Create user...")

        err := u.DB.Create(&amp;user).Error

        return user, err
}</span>


// Add the user to the DB
func (u usersRepository) OneUser(id string, user models.Users) (models.Users, error) <span class="cov0" title="0">{
        log.Println("[UsersRepository] One user...")

        err := u.DB.First(&amp;user, id).Error

        return user, err
}</span>

// Update user to the DB
func (u usersRepository) UpdateUser(user models.Users) (models.Users, error) <span class="cov0" title="0">{
        log.Println("[UsersRepository] Update User...")

        err := u.DB.Update("Update", &amp;user).Error

        return user, err
}</span>

// Delete user from the DB
func (u usersRepository) DeleteUser(user models.Users) (models.Users, error) <span class="cov8" title="1">{
        log.Println("[UsersRepository] Delete User...")

        err := u.DB.Delete(&amp;user).Error

        return user, err
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package service

import (
        "github.com/VolunteerOne/volunteer-one-app/backend/models"
        "github.com/VolunteerOne/volunteer-one-app/backend/repository"
        "github.com/gin-gonic/gin"
)

type EventService interface {
        CreateEvent(models.Event) (models.Event, error)
        GetEvents() ([]models.Event, error)
        GetEventById(string) (models.Event, error)
        UpdateEvent(models.Event) (models.Event, error)
        DeleteEvent(models.Event) error
        Bind(*gin.Context, any) error
}

type eventService struct {
        eventRepository repository.EventRepository
}

// CreateEvent implements EventService
func (s eventService) CreateEvent(event models.Event) (models.Event, error) <span class="cov8" title="1">{
        return s.eventRepository.CreateEvent(event)
}</span>

// DeleteEvent implements EventService
func (s eventService) DeleteEvent(event models.Event) error <span class="cov8" title="1">{
        return s.eventRepository.DeleteEvent(event)
}</span>

// GetEventById implements EventService
func (s eventService) GetEventById(id string) (models.Event, error) <span class="cov8" title="1">{
        return s.eventRepository.GetEventById(id)
}</span>

// GetEvents implements EventService
func (s eventService) GetEvents() ([]models.Event, error) <span class="cov8" title="1">{
        return s.eventRepository.GetEvents()
}</span>

// UpdateEvent implements EventService
func (s eventService) UpdateEvent(event models.Event) (models.Event, error) <span class="cov8" title="1">{
        return s.eventRepository.UpdateEvent(event)
}</span>

func NewEventService(r repository.EventRepository) EventService <span class="cov8" title="1">{
        return eventService{
                eventRepository: r,
        }
}</span>

func (s eventService) Bind(c *gin.Context, obj any) error <span class="cov8" title="1">{
        return c.Bind(obj)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package service

import (
        "github.com/gin-gonic/gin"
        "log"

        "github.com/VolunteerOne/volunteer-one-app/backend/models"
        "github.com/VolunteerOne/volunteer-one-app/backend/repository"
)

type FriendService interface {
        CreateFriend(friend models.Friend) (models.Friend, error)
        AcceptFriend(friend models.Friend) (models.Friend, error)
        RejectFriend(friend models.Friend) error
        OneFriend(id string) (models.Friend, error)
        GetFriends() ([]models.Friend, error)
        Bind(*gin.Context, any) error
}

type friendService struct {
        friendRepository repository.FriendRepository
}

func NewFriendService(r repository.FriendRepository) FriendService <span class="cov8" title="1">{
        return friendService{
                friendRepository: r,
        }
}</span>

func (f friendService) CreateFriend(friend models.Friend) (models.Friend, error) <span class="cov8" title="1">{
        log.Println("[FriendService] Create friend request...")
        return f.friendRepository.CreateFriend(friend)
}</span>

func (f friendService) AcceptFriend(friend models.Friend) (models.Friend, error) <span class="cov8" title="1">{
        log.Println("[FriendService] Accept friend...")
        return f.friendRepository.AcceptFriend(friend)
}</span>

func (f friendService) RejectFriend(friend models.Friend) error <span class="cov8" title="1">{
        log.Println("[FriendService] Reject friend...")
        return f.friendRepository.RejectFriend(friend)
}</span>

func (f friendService) OneFriend(id string) (models.Friend, error) <span class="cov8" title="1">{
        log.Println("[FriendService] Accept friend...")
        return f.friendRepository.OneFriend(id)
}</span>

func (f friendService) GetFriends() ([]models.Friend, error) <span class="cov8" title="1">{
        log.Println("[FriendService] Get all friends...")
        return f.friendRepository.GetFriends()
}</span>

func (f friendService) Bind(c *gin.Context, obj any) error <span class="cov8" title="1">{
        return c.Bind(obj)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package service

import (
        "github.com/VolunteerOne/volunteer-one-app/backend/middleware"
        "github.com/VolunteerOne/volunteer-one-app/backend/models"
        "github.com/VolunteerOne/volunteer-one-app/backend/repository"
        "github.com/go-gomail/gomail"
        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
        "golang.org/x/crypto/bcrypt"
        "time"
)

type LoginService interface {
        FindUserFromEmail(string, models.Users) (models.Users, error)
        SaveResetCodeToUser(uuid.UUID, models.Users) error
        ChangePassword([]byte, models.Users) error
        HashPassword([]byte) ([]byte, error)
        CompareHashedAndUserPass([]byte, string) error
        GenerateJWT(jwt.SigningMethod, jwt.Claims, string) (string, error)
        GenerateExpiresJWT() (*jwt.NumericDate, *jwt.NumericDate)
        ValidateJWT(string, string) (*jwt.Token, error)
        SaveRefreshToken(uint, string, models.Delegations) error
        FindRefreshToken(float64, models.Delegations) (models.Delegations, error)
        DeleteRefreshToken(models.Delegations) error
        ParseUUID(string) (uuid.UUID, error)
        MapJWTClaims(jwt.Token) (jwt.MapClaims, bool)
        GenerateUUID() uuid.UUID
        SendResetCodeToEmail(string, string) error
}

type loginService struct {
        loginRepository repository.LoginRepository
}

// Instantiated in router.go
func NewLoginService(r repository.LoginRepository) LoginService <span class="cov8" title="1">{
        return loginService{
                loginRepository: r,
        }
}</span>

func (l loginService) FindUserFromEmail(email string, user models.Users) (models.Users, error) <span class="cov8" title="1">{
        return l.loginRepository.FindUserFromEmail(email, user)
}</span>

func (l loginService) SaveResetCodeToUser(resetCode uuid.UUID, user models.Users) error <span class="cov8" title="1">{
        return l.loginRepository.SaveResetCodeToUser(resetCode, user)
}</span>

func (l loginService) ChangePassword(newPassword []byte, user models.Users) error <span class="cov8" title="1">{
        return l.loginRepository.ChangePassword(newPassword, user)
}</span>

func (l loginService) HashPassword(password []byte) ([]byte, error) <span class="cov8" title="1">{
        return bcrypt.GenerateFromPassword([]byte(password), 10)
}</span>

func (l loginService) CompareHashedAndUserPass(hashedPassword []byte, stringPassword string) error <span class="cov8" title="1">{
        return bcrypt.CompareHashAndPassword(hashedPassword, []byte(stringPassword))
}</span>

func (l loginService) GenerateJWT(
        signingMethod jwt.SigningMethod,
        claims jwt.Claims,
        secret string) (string, error) <span class="cov8" title="1">{

        token := jwt.NewWithClaims(signingMethod, claims)
        return token.SignedString([]byte(secret))
}</span>

func (l loginService) GenerateExpiresJWT() (*jwt.NumericDate, *jwt.NumericDate) <span class="cov8" title="1">{
        // 15 minute expire for accessToken
        accessExpire := jwt.NewNumericDate(time.Now().Add(time.Minute * 15))
        // 1 day expire for refreshToken
        refreshExpire := jwt.NewNumericDate(time.Now().Add(time.Hour * 24))
        return accessExpire, refreshExpire
}</span>

func (l loginService) ValidateJWT(token string, secret string) (*jwt.Token, error) <span class="cov8" title="1">{
        // hooks into middleware
        return middleware.Validate(token, secret)
}</span>

func (l loginService) MapJWTClaims(token jwt.Token) (jwt.MapClaims, bool) <span class="cov8" title="1">{
        claims, ok := token.Claims.(jwt.MapClaims)
        return claims, ok
}</span>

func (l loginService) SaveRefreshToken(userid uint, refreshToken string, deleg models.Delegations) error <span class="cov8" title="1">{
        return l.loginRepository.SaveRefreshToken(userid, refreshToken, deleg)
}</span>

func (l loginService) FindRefreshToken(userid float64, deleg models.Delegations) (models.Delegations, error) <span class="cov8" title="1">{
        return l.loginRepository.FindRefreshToken(userid, deleg)
}</span>

func (l loginService) DeleteRefreshToken(deleg models.Delegations) error <span class="cov8" title="1">{
        return l.loginRepository.DeleteRefreshToken(deleg)
}</span>

func (l loginService) ParseUUID(s string) (uuid.UUID, error) <span class="cov8" title="1">{
        return uuid.Parse(s)
}</span>

func (l loginService) GenerateUUID() uuid.UUID <span class="cov8" title="1">{
        return uuid.New()
}</span>

func (l loginService) SendResetCodeToEmail(email string, resetCode string) error <span class="cov8" title="1">{
        mailer := gomail.NewMessage()
        mailer.SetHeader("From", "edwardsung4217@gmail.com") //need to replace this with proper volunteer email
        mailer.SetHeader("To", email)
        mailer.SetHeader("Subject", "Password Reset Code")
        mailer.SetBody("text/plain", "Your password reset code is "+resetCode)
        return gomail.NewDialer("smtp.sendgrid.net", 465, "apikey", "APIKEY").DialAndSend(mailer)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package service

import (
        "github.com/VolunteerOne/volunteer-one-app/backend/models"
        "github.com/VolunteerOne/volunteer-one-app/backend/repository"
)

type OrgUsersService interface {
        CreateOrgUser(models.OrgUsers) (models.OrgUsers, error)
        ListAllOrgUsers() ([]models.OrgUsers, error)
        FindOrgUser(uint, uint) (models.OrgUsers, error)
        UpdateOrgUser(uint, uint, uint) (models.OrgUsers, error)
        DeleteOrgUser(uint, uint) error
}

type orgUsersService struct {
        orgUsersRepository repository.OrgUsersRepository
}

// Instantiated in router.go
func NewOrgUsersService(r repository.OrgUsersRepository) OrgUsersService <span class="cov8" title="1">{
        return orgUsersService{
                orgUsersRepository: r,
        }
}</span>

func (o orgUsersService) CreateOrgUser(orgUser models.OrgUsers) (models.OrgUsers, error) <span class="cov8" title="1">{
        return o.orgUsersRepository.CreateOrgUser(orgUser)
}</span>

func (o orgUsersService) ListAllOrgUsers() ([]models.OrgUsers, error) <span class="cov8" title="1">{
        return o.orgUsersRepository.ListAllOrgUsers()
}</span>

func (o orgUsersService) FindOrgUser(userId uint, orgId uint) (models.OrgUsers, error) <span class="cov8" title="1">{
        return o.orgUsersRepository.FindOrgUser(userId, orgId)
}</span>

func (o orgUsersService) UpdateOrgUser(userId uint, orgId uint, role uint) (models.OrgUsers, error) <span class="cov8" title="1">{
        return o.orgUsersRepository.UpdateOrgUser(userId, orgId, role)
}</span>

func (o orgUsersService) DeleteOrgUser(userId uint, orgId uint) error <span class="cov8" title="1">{
        return o.orgUsersRepository.DeleteOrgUser(userId, orgId)
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package service

import (
        "github.com/VolunteerOne/volunteer-one-app/backend/models"
        "github.com/VolunteerOne/volunteer-one-app/backend/repository"
        "github.com/gin-gonic/gin"
)

type OrganizationService interface {
        CreateOrganization(models.Organization) (models.Organization, error)
        GetOrganizations() ([]models.Organization, error)
        GetOrganizationById(string) (models.Organization, error)
        UpdateOrganization(models.Organization) (models.Organization, error)
        DeleteOrganization(models.Organization) error
        Bind(*gin.Context, any) error
}

type organizationService struct {
        organizationRepository repository.OrganizationRepository
}

// CreateOrganization implements OrganizationService
func (s organizationService) CreateOrganization(org models.Organization) (models.Organization, error) <span class="cov8" title="1">{
        return s.organizationRepository.CreateOrganization(org)
}</span>

// DeleteOrganization implements OrganizationService
func (s organizationService) DeleteOrganization(org models.Organization) error <span class="cov8" title="1">{
        return s.organizationRepository.DeleteOrganization(org)
}</span>

// GetOrganizationById implements OrganizationService
func (s organizationService) GetOrganizationById(id string) (models.Organization, error) <span class="cov8" title="1">{
        return s.organizationRepository.GetOrganizationById(id)
}</span>

// GetOrganizations implements OrganizationService
func (s organizationService) GetOrganizations() ([]models.Organization, error) <span class="cov8" title="1">{
        return s.organizationRepository.GetOrganizations()
}</span>

// UpdateOrganization implements OrganizationService
func (s organizationService) UpdateOrganization(org models.Organization) (models.Organization, error) <span class="cov8" title="1">{
        return s.organizationRepository.UpdateOrganization(org)
}</span>

func NewOrganizationService(r repository.OrganizationRepository) OrganizationService <span class="cov8" title="1">{
        return organizationService{
                organizationRepository: r,
        }
}</span>

func (s organizationService) Bind(c *gin.Context, obj any) error <span class="cov8" title="1">{
        return c.Bind(obj)
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package service

import (
        "github.com/VolunteerOne/volunteer-one-app/backend/models"
        "github.com/VolunteerOne/volunteer-one-app/backend/repository"
        "github.com/gin-gonic/gin"
)

type PostsService interface {
        CreatePost(post models.Posts) (models.Posts, error)
        DeletePost(post models.Posts) error
        EditPost(post models.Posts) (models.Posts, error)
        FindPost(id string) (models.Posts, error)
        AllPosts() ([]models.Posts, error)
        Bind(*gin.Context, any) error
}

type postsService struct {
        postsRepository repository.PostsRepository
}

func NewPostsService(r repository.PostsRepository) PostsService <span class="cov8" title="1">{
        return postsService{
                postsRepository: r,
        }
}</span>

type CommentsService interface {
        CreateComment(comment models.Comments) (models.Comments, error)
        DeleteComment(comment models.Comments) error
        EditComment(comment models.Comments) (models.Comments, error)
        FindComment(id string) (models.Comments, error)
        AllComments() ([]models.Comments, error)
        Bind(*gin.Context, any) error
}

type commentsService struct {
        commentsRepository repository.CommentsRepository
}

func NewCommentsService(r repository.CommentsRepository) CommentsService <span class="cov8" title="1">{
        return commentsService{
                commentsRepository: r,
        }
}</span>

type LikesService interface {
        CreateLike(like models.Likes) (models.Likes, error)
        DeleteLike(like models.Likes) error
        FindLike(id string) (models.Likes, error)
        AllLikes() ([]models.Likes, error)
        GetLikes(id string) (int64, error)
        Bind(*gin.Context, any) error
}

type likesService struct {
        likesRepository repository.LikesRepository
}

func NewLikesService(r repository.LikesRepository) LikesService <span class="cov8" title="1">{
        return likesService{
                likesRepository: r,
        }
}</span>

func (f postsService) CreatePost(post models.Posts) (models.Posts, error) <span class="cov8" title="1">{
        return f.postsRepository.CreatePost(post)
}</span>

func (f postsService) DeletePost(post models.Posts) error <span class="cov8" title="1">{
        return f.postsRepository.DeletePost(post)
}</span>

func (f postsService) EditPost(post models.Posts) (models.Posts, error) <span class="cov8" title="1">{
        return f.postsRepository.EditPost(post)
}</span>

func (f postsService) FindPost(id string) (models.Posts, error) <span class="cov8" title="1">{
        return f.postsRepository.FindPost(id)
}</span>

func (f postsService) AllPosts() ([]models.Posts, error) <span class="cov8" title="1">{
        return f.postsRepository.AllPosts()
}</span>

func (f postsService) Bind(c *gin.Context, obj any) error <span class="cov8" title="1">{
        return c.Bind(obj)
}</span>

func (f commentsService) CreateComment(comment models.Comments) (models.Comments, error) <span class="cov8" title="1">{
        return f.commentsRepository.CreateComment(comment)
}</span>

func (f commentsService) DeleteComment(comment models.Comments) error <span class="cov8" title="1">{
        return f.commentsRepository.DeleteComment(comment)
}</span>

func (f commentsService) EditComment(comment models.Comments) (models.Comments, error) <span class="cov8" title="1">{
        return f.commentsRepository.EditComment(comment)
}</span>

func (f commentsService) FindComment(id string) (models.Comments, error) <span class="cov8" title="1">{
        return f.commentsRepository.FindComment(id)
}</span>

func (f commentsService) AllComments() ([]models.Comments, error) <span class="cov8" title="1">{
        return f.commentsRepository.AllComments()
}</span>

func (f commentsService) Bind(c *gin.Context, obj any) error <span class="cov8" title="1">{
        return c.Bind(obj)
}</span>

func (f likesService) CreateLike(like models.Likes) (models.Likes, error) <span class="cov8" title="1">{
        return f.likesRepository.CreateLike(like)
}</span>

func (f likesService) DeleteLike(like models.Likes) error <span class="cov8" title="1">{
        return f.likesRepository.DeleteLike(like)
}</span>

func (f likesService) FindLike(id string) (models.Likes, error) <span class="cov8" title="1">{
        return f.likesRepository.FindLike(id)
}</span>

func (f likesService) AllLikes() ([]models.Likes, error) <span class="cov8" title="1">{
        return f.likesRepository.AllLikes()
}</span>

func (f likesService) GetLikes(id string) (int64, error) <span class="cov8" title="1">{
        return f.likesRepository.GetLikes(id)
}</span>

func (f likesService) Bind(c *gin.Context, obj any) error <span class="cov8" title="1">{
        return c.Bind(obj)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package service

import (
        "log"

        "github.com/VolunteerOne/volunteer-one-app/backend/models"
        "github.com/VolunteerOne/volunteer-one-app/backend/repository"
        "golang.org/x/crypto/bcrypt"
)

type UsersService interface {
        CreateUser(user models.Users) (models.Users, error)
        OneUser(id string, user models.Users) (models.Users, error)
        UpdateUser(user models.Users) (models.Users, error)
        DeleteUser(user models.Users) (models.Users, error)
        HashPassword(password []byte) ([]byte, error)
}

type usersService struct {
        usersRepository repository.UsersRepository
}

func NewUsersService(r repository.UsersRepository) UsersService <span class="cov8" title="1">{
        return usersService{
                usersRepository: r,
        }
}</span>

func (u usersService) CreateUser(user models.Users) (models.Users, error) <span class="cov8" title="1">{
        log.Println("[UsersService] Create user...")

        return u.usersRepository.CreateUser(user)
}</span>

func (u usersService) OneUser(id string, user models.Users) (models.Users, error) <span class="cov0" title="0">{
        log.Println("[UsersService] Get One User...")

        return u.usersRepository.OneUser(id, user)
}</span>

func (u usersService) UpdateUser(user models.Users) (models.Users, error) <span class="cov0" title="0">{
        log.Println("[UsersService] Update User...")

        return u.usersRepository.UpdateUser(user)
}</span>

func (u usersService) DeleteUser(user models.Users) (models.Users, error) <span class="cov8" title="1">{
        log.Println("[UsersService] Delete User...")

        return u.usersRepository.DeleteUser(user)
}</span>

func (u usersService) HashPassword(password []byte) ([]byte, error) <span class="cov0" title="0">{
        hash, err := bcrypt.GenerateFromPassword([]byte(password), 10)
        return hash, err
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
